-- =========
-- BASICS
-- =========

-- Longhorn Preflight Schema
-- Run this in Supabase Dashboard: Database â†’ SQL Editor

-- Create messages table
CREATE TABLE IF NOT EXISTS public.messages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL,
    content TEXT NOT NULL CHECK (length(content) <= 1000),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Enable Row Level Security
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist (for clean setup)
DROP POLICY IF EXISTS "select_any_authenticated" ON public.messages;
DROP POLICY IF EXISTS "insert_any_authenticated" ON public.messages;

-- Create policy for SELECT: any authenticated user can read all messages
CREATE POLICY "select_any_authenticated" 
ON public.messages 
FOR SELECT 
USING (auth.role() = 'authenticated');

-- Create policy for INSERT: any authenticated user can insert messages
CREATE POLICY "insert_any_authenticated" 
ON public.messages 
FOR INSERT 
WITH CHECK (auth.role() = 'authenticated');

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON public.messages TO authenticated;
GRANT USAGE ON SEQUENCE public.messages_id_seq TO authenticated;
create extension if not exists pgcrypto;

-- 0) Profiles: a row per auth user (handy for names/avatars)
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  username text unique,
  full_name text,
  avatar_url text,
  created_at timestamptz not null default now()
);

alter table public.profiles enable row level security;

-- Anyone authenticated can read profiles; users can insert/update their own
create policy profiles_select_any on public.profiles
for select using (auth.role() = 'authenticated');

create policy profiles_insert_self on public.profiles
for insert with check (auth.uid() = id);

create policy profiles_update_self on public.profiles
for update using (auth.uid() = id);

-- =========
-- FRIENDS
-- =========
create type friend_status as enum ('pending','accepted','declined');

create table if not exists public.friends (
  id bigserial primary key,
  requester_id uuid not null references auth.users(id) on delete cascade,
  addressee_id uuid not null references auth.users(id) on delete cascade,
  status friend_status not null default 'pending',
  created_at timestamptz not null default now(),
  unique (requester_id, addressee_id),
  check (requester_id <> addressee_id)
);

alter table public.friends enable row level security;

-- You can see friend rows that involve you
create policy friends_select_involved on public.friends
for select using (
  auth.uid() = requester_id or auth.uid() = addressee_id
);

-- You can create a request only as the requester
create policy friends_insert_requester on public.friends
for insert with check (auth.uid() = requester_id);

-- Only the addressee can update status (accept/decline)
create policy friends_update_addressee on public.friends
for update using (auth.uid() = addressee_id);

-- =========
-- CONVERSATIONS (1:1)
-- =========
create table if not exists public.conversations (
  id uuid primary key default gen_random_uuid(),
  created_at timestamptz not null default now()
);

create table if not exists public.conversation_participants (
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  last_read_at timestamptz,
  inserted_at timestamptz not null default now(),
  primary key (conversation_id, user_id)
);

alter table public.conversation_participants enable row level security;

-- Only see/insert/update your own participant rows
create policy convp_select_self on public.conversation_participants
for select using (auth.uid() = user_id);

create policy convp_insert_self on public.conversation_participants
for insert with check (auth.uid() = user_id);

create policy convp_update_self on public.conversation_participants
for update using (auth.uid() = user_id);

-- =========
-- MESSAGES
-- =========
create table if not exists public.direct_messages (
  id bigserial primary key,
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  sender_id uuid not null references auth.users(id) on delete cascade,
  content text not null check (length(content) <= 2000),
  created_at timestamptz not null default now()
);

alter table public.direct_messages enable row level security;

-- Only participants in the conversation can read messages
create policy dm_select_participants on public.direct_messages
for select using (
  exists (
    select 1 from public.conversation_participants cp
    where cp.conversation_id = direct_messages.conversation_id
      and cp.user_id = auth.uid()
  )
);

-- Sender must be a participant of the conversation
create policy dm_insert_sender on public.direct_messages
for insert with check (
  auth.uid() = sender_id and
  exists (
    select 1 from public.conversation_participants cp
    where cp.conversation_id = direct_messages.conversation_id
      and cp.user_id = auth.uid()
  )
);

-- =========
-- HELPERS
-- =========
-- Returns a 1:1 conversation id between two users, creating if missing
create or replace function public.get_or_create_conversation(a uuid, b uuid)
returns uuid
language plpgsql
as $$
declare
  convo uuid;
begin
  if a = b then raise exception 'Cannot create conversation with self'; end if;

  select c.id into convo
  from public.conversations c
  join public.conversation_participants p1 on p1.conversation_id = c.id and p1.user_id = a
  join public.conversation_participants p2 on p2.conversation_id = c.id and p2.user_id = b
  limit 1;

  if convo is null then
    insert into public.conversations default values returning id into convo;
    insert into public.conversation_participants (conversation_id, user_id)
    values (convo, a), (convo, b);
  end if;

  return convo;
end;
$$;

-- Useful indexes
create index if not exists idx_friends_me_status_req on public.friends(requester_id, status);
create index if not exists idx_friends_me_status_addr on public.friends(addressee_id, status);
create index if not exists idx_dm_convo_created on public.direct_messages(conversation_id, created_at desc);

-- Grants (for authenticated role)
grant usage on schema public to authenticated;
grant select, insert, update on public.profiles, public.friends, public.conversation_participants to authenticated;
grant select, insert on public.direct_messages to authenticated;